library(dplyr)
library(tidyr)
library(ggplot2)
library(writexl)
library(readxl)
library(segmented)
library(ggpubr)
library(viridis)
library(ggrepel)
library(randtests)
library(igraph)
library(minpack.lm)
library(pracma)
library(statcomp)
library(grid)
library(gridExtra)

library(Hmisc)
library(cluster)
library(factoextra)

library(seqinr)

# load lofreq snps

lofreq.be.vcfs <- lapply(paste0("lofreqout_vslow/", list.files(path = "lofreqout_vslow/", pattern = "PVYbe.*vcf")) %>%
                           setNames(nm = list.files(path = "lofreqout_vslow/", pattern = "PVYbe.*vcf")),
                         function(x) {
                           read.table(x, comment.char = "#", sep = "\t",
                                      col.names = c("CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", "INFO")) %>%
                             filter(CHROM == "PVYbe_final_cons")
                         })

lofreq.po.vcfs <- lapply(paste0("lofreqout_vslow/", list.files(path = "lofreqout_vslow/", pattern = "PVYpo.*vcf")) %>%
                           setNames(nm = list.files(path = "lofreqout_vslow/", pattern = "PVYpo.*vcf")),
                         function(x) {
                           read.table(x, comment.char = "#", sep = "\t",
                                      col.names = c("CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", "INFO")) %>%
                             filter(CHROM == "PVYpo_final_cons")
                         })

# compute a table of the possible syn and nonsyn mutation for each codon

mut.tb <- data.frame(codon = character(),
                     n.syn = numeric(),
                     n.nonsyn = numeric())

nucl <- c("A", "C", "T", "G")

lapply(nucl, function(pos1) {
  lapply(nucl, function(pos2) {
    lapply(nucl, function(pos3) {
      
      # calculate the number of syn and nonsyn mutations at each codon position independently
      
      possible.alt1 <- nucl[nucl != pos1]
      possible.alt3 <- nucl[nucl != pos3]
      
      codon <- paste0(pos1, pos2, pos3)
      curr.aa <- translate(c(pos1, pos2, pos3))
      
      n.syn1 <- length(possible.alt1[lapply(possible.alt1, function(x) {
        alt.aa <- c(x, pos2, pos3) %>% translate()
        curr.aa == alt.aa
      }) %>% unlist()]) 
      
      n.syn3 <- length(possible.alt3[lapply(possible.alt3, function(x) {
        alt.aa <- c(pos1, pos2, x) %>% translate()
        curr.aa == alt.aa
      }) %>% unlist()])
      
      n.syn <- n.syn1 + n.syn3
      n.nonsyn <- 9 - n.syn
      
      mut.tb[nrow(mut.tb) + 1,] <<- list(codon, n.syn, n.nonsyn)
    })
  })
}) %>% invisible()

# load ref

ref <- c(read.fasta("consensus/PVYbe_cons.fasta"),
         read.fasta("consensus/PVYpo_cons.fasta"))

# functions

#' check_snp
#' 
#' Function to compute whether SNPs are syn or nonsyn
#' 
#' @param ref Reference sequence
#' @param vcf VCF file generated by lofreq
#' @param start ORF start position (always < end, even when strand == "-")
#' @param end ORF end
#' @param strand "+" or "-"
#' 
#' @return A list of syn or nonsyn for each SNP
#' @export
#' 
#' @examples
check_snp <- function(ref,
                      vcf,
                      start, # start < end even if strand = "-"
                      end,
                      strand = "+") {
  
  seq <- ref[start:end]
  if (strand == "-") aa <- translate(rev(comp(seq)))
  else aa <- translate(seq)
  
  vcf <- vcf[vcf$POS >= start & vcf$POS <= end,]
  
  if(nrow(vcf) == 0) return(list())
  
  vcf$mut <- paste0(vcf$REF, vcf$POS, vcf$ALT)
  vcf$POS <- vcf$POS - start + 1 # position in ORF

  mut.type <- apply(vcf, 1, function(x) {
    alt.seq <- seq
    pos <- x[["POS"]] %>% as.numeric()
    alt.seq[[pos]] <- x[["ALT"]] %>% tolower()
    
    if (strand == "-") alt.aa <- translate(rev(comp(alt.seq)))
    else alt.aa <- translate(alt.seq)
    
    if (isTRUE(all.equal(aa, alt.aa))) return("syn")
    else return("nonsyn")
  })
  names(mut.type) <- vcf$mut
  return(mut.type)
}

#' shannon.entropy
#' 
#' Shannon entropy at position
#' 
#' @param freq.lst frequencies of each base
#' 
#' @return Shannon entropy
#' @export
#' 
#' @examples
shannon.entropy <- function(freq.lst) -sum(lapply(freq.lst, function(x) x * log(x, 2)) %>% unlist())

#' calc.entropy
#' 
#' Calculate entropies for each allele frequency
#' 
#' @param alt.freq.list List of alternative allele frequencies
#' @param return.sum Return the sum of the entropies
#' 
#' @return Shannon entropy sum
#' @export
#' 
#' @examples
calc.entropy <- function(alt.freq.lst,
                         return.sum = TRUE) {
  
  if (sum(alt.freq.lst) == 0) return(0)
  
  # remove 0 or 1 variants
  
  alt.freq.lst <- alt.freq.lst[!alt.freq.lst %in% c(0, 1)]
  
  # get snps at same site
  
  sites <- names(alt.freq.lst) %>%
    gsub("[A-Z+-]*", "", .) %>% unique()
  
  # calcute entropy
  
  entropies <- lapply(setNames(nm = sites), function(x) {
    snps <- alt.freq.lst[grepl(paste0("[ACTG]", x, "[ACTG]"), names(alt.freq.lst))]
    ref.freq <- 1 - sum(snps)
    shannon.entropy(c(snps, ref.freq))
  })
  
  if (return.sum) sum(entropies %>% unlist()) %>% return()
  else return(entropies)
}

#' calc.afd
#' 
#' Calculate AFD between two populations
#' 
#' @param AF.tb Two-column data frame with allele frequencies
#' 
#' @return AFD
#' @export
#' 
#' @examples
calc.afd <- function(AF.tb,
                     sum = TRUE) {
  
  # get snps at same site
  
  sites <- row.names(AF.tb) %>%
    gsub("[A-Z+-]*", "", .) %>% gsub("\\*", "", .) %>% unique()
  
  # calcute afd
  
  afd <- lapply(setNames(nm = sites), function(x) {
    
    alleles <- AF.tb[grepl(paste0("[ACTG]", x, "[ACTG]"), row.names(AF.tb)),]
    alleles["ref",] <- 1 - colSums(alleles)
    alleles.diff <- abs(alleles[1] - alleles[2])
    colSums(alleles.diff) / 2
    
  }) %>% unlist()
  
  if (sum) return(sum(afd))
  return(afd)
}

#' calc.apd
#' 
#' Calculate APD of a population
#' 
#' @param vcf.lst VSF file generated by lofreq
#' @param genome.length Genome length
#' 
#' @return APD
#' @export
#' 
#' @examples
calc.apd <- function(vcf.lst,
                     genome.length) {
  
  vcf.lst %>% lapply(function(x) {
    
    pos <- x$POS %>% unique()
    
   apd = lapply(setNames(nm = pos), function(y) {
      
      vcf.pos <- x[x$POS == y,]
      vcf.pos <- vcf.pos %>% dplyr::mutate(dp4 = INFO %>% gsub(".*DP4=", "", .)) %>%
        separate(col = "dp4", c("for_ref", "rev_ref", "for_alt", "rev_alt")) %>%
        dplyr::mutate(REF_count = as.numeric(for_ref) + as.numeric(rev_ref),
                      ALT_count = as.numeric(for_alt) + as.numeric(rev_alt)) %>%
        dplyr::select(c(REF, ALT, REF_count, ALT_count))
      
      nuc.counts <- data.frame(base = c(vcf.pos$REF[1], vcf.pos$ALT),
                               count = c(vcf.pos$REF_count[1], vcf.pos$ALT_count))
      
      n.lst <- list(A = nuc.counts[nuc.counts$base == "A", "count"],
                    C = nuc.counts[nuc.counts$base == "C", "count"],
                    U = nuc.counts[nuc.counts$base == "T", "count"],
                    G = nuc.counts[nuc.counts$base == "G", "count"]) %>%
        lapply(function(x) if (length(x) == 0) return(0) else return(x))
      
      ((n.lst$A * (n.lst$C + n.lst$G + n.lst$G)) + (n.lst$C * (n.lst$G + n.lst$U)) + (n.lst$G * n.lst$U)) /
         (sum(n.lst %>% unlist()) * (sum(n.lst %>% unlist()) - 1))
      
    }) %>% unlist() %>% sum()
    
   apd * (2 / genome.length)
  })
}
